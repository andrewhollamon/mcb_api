package error

import (
	"fmt"
	"github.com/google/uuid"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// NOTE: The errors code was generated by claude code, and is still being worked through for changes

type APIError interface {
	error
	StatusCode() int
	ErrorCode() string
	TraceID() string
	Context() map[string]interface{}
	WithContext(key string, value interface{}) APIError
	WithTrace(traceID string) APIError
	Respond(c *gin.Context)
}

type baseError struct {
	code       string
	message    string
	statusCode int
	traceID    string
	context    map[string]interface{}
	timestamp  time.Time
}

func (e *baseError) Error() string {
	return fmt.Sprintf("[%s] %s (trace: %s)", e.code, e.message, e.traceID)
}

func (e *baseError) StatusCode() int {
	return e.statusCode
}

func (e *baseError) ErrorCode() string {
	return e.code
}

func (e *baseError) TraceID() string {
	return e.traceID
}

func (e *baseError) Context() map[string]interface{} {
	return e.context
}

func (e *baseError) WithContext(key string, value interface{}) APIError {
	newErr := *e
	if newErr.context == nil {
		newErr.context = make(map[string]interface{})
	}
	newErr.context[key] = value
	return &newErr
}

func (e *baseError) WithTrace(traceID string) APIError {
	newErr := *e
	newErr.traceID = traceID
	return &newErr
}

func (e *baseError) Respond(c *gin.Context) {
	response := gin.H{
		"error": gin.H{
			"code":      e.code,
			"message":   e.message,
			"trace_id":  e.traceID,
			"timestamp": e.timestamp.Format(time.RFC3339),
		},
	}

	if len(e.context) > 0 {
		response["error"].(gin.H)["context"] = e.context
	}

	c.Header("X-Trace-ID", e.traceID)
	c.JSON(e.statusCode, response)
}

type ValidationError struct {
	*baseError
}

type InternalError struct {
	*baseError
	cause error
}

func (e *InternalError) Unwrap() error {
	return e.cause
}

func (e *InternalError) Cause() error {
	return e.cause
}

func newError(code, message string, statusCode int) *baseError {
	traceID, _ := uuid.NewV7()
	return &baseError{
		code:       code,
		message:    message,
		statusCode: statusCode,
		traceID:    traceID.String(),
		context:    make(map[string]interface{}),
		timestamp:  time.Now().UTC(),
	}
}

func NewValidationError(code, message string) APIError {
	return &ValidationError{
		baseError: newError(code, message, http.StatusBadRequest),
	}
}

func NewUnauthorizedError(message string) APIError {
	return &ValidationError{
		baseError: newError("UNAUTHORIZED", message, http.StatusUnauthorized),
	}
}

func NewForbiddenError(message string) APIError {
	return &ValidationError{
		baseError: newError("FORBIDDEN", message, http.StatusForbidden),
	}
}

func NewNotFoundError(message string) APIError {
	return &ValidationError{
		baseError: newError("NOT_FOUND", message, http.StatusNotFound),
	}
}

func NewConflictError(message string) APIError {
	return &ValidationError{
		baseError: newError("CONFLICT", message, http.StatusConflict),
	}
}

func NewTooManyRequestsError(message string) APIError {
	return &ValidationError{
		baseError: newError("TOO_MANY_REQUESTS", message, http.StatusTooManyRequests),
	}
}

func NewInternalError(message string, cause error) APIError {
	return &InternalError{
		baseError: newError("INTERNAL_ERROR", message, http.StatusInternalServerError),
		cause:     cause,
	}
}

func NewServiceUnavailableError(message string, cause error) APIError {
	return &InternalError{
		baseError: newError("SERVICE_UNAVAILABLE", message, http.StatusServiceUnavailable),
		cause:     cause,
	}
}

func NewDatabaseError(message string, cause error) APIError {
	return &InternalError{
		baseError: newError("DATABASE_ERROR", message, http.StatusInternalServerError),
		cause:     cause,
	}
}

func NewQueueError(message string, cause error) APIError {
	return &InternalError{
		baseError: newError("QUEUE_ERROR", message, http.StatusInternalServerError),
		cause:     cause,
	}
}

func FromGinContext(c *gin.Context, code, message string, statusCode int) APIError {
	err := newError(code, message, statusCode)

	if requestID := c.GetHeader("X-Request-ID"); requestID != "" {
		err.traceID = requestID
	}

	err.context["request_method"] = c.Request.Method
	err.context["request_path"] = c.Request.URL.Path

	if c.Request.URL.RawQuery != "" {
		err.context["request_query"] = c.Request.URL.RawQuery
	}

	err.context["user_agent"] = c.GetHeader("User-Agent")
	err.context["client_ip"] = c.ClientIP()

	if statusCode >= 500 {
		return &InternalError{baseError: err}
	}
	return &ValidationError{baseError: err}
}

func HandlePanic(c *gin.Context) {
	if r := recover(); r != nil {
		var err APIError
		switch v := r.(type) {
		case APIError:
			err = v
		case error:
			err = NewInternalError("Internal server error", v)
		case string:
			err = NewInternalError(v, nil)
		default:
			err = NewInternalError("Unknown panic occurred", nil)
		}

		if existingTraceID := c.GetHeader("X-Trace-ID"); existingTraceID != "" {
			err = err.WithTrace(existingTraceID)
		}

		err.Respond(c)
		c.Abort()
	}
}
